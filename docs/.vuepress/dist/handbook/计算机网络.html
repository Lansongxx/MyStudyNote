<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络 | 八股速记</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="面试前快速背诵八股">
    
    <link rel="preload" href="/MyStudyNote/assets/css/0.styles.8bcb82ca.css" as="style"><link rel="preload" href="/MyStudyNote/assets/js/app.9d2cd43a.js" as="script"><link rel="preload" href="/MyStudyNote/assets/js/2.7df07032.js" as="script"><link rel="preload" href="/MyStudyNote/assets/js/13.699ad82a.js" as="script"><link rel="prefetch" href="/MyStudyNote/assets/js/10.e5e65939.js"><link rel="prefetch" href="/MyStudyNote/assets/js/11.3953e262.js"><link rel="prefetch" href="/MyStudyNote/assets/js/12.756b5d3a.js"><link rel="prefetch" href="/MyStudyNote/assets/js/3.b2917d40.js"><link rel="prefetch" href="/MyStudyNote/assets/js/4.a5aefbd5.js"><link rel="prefetch" href="/MyStudyNote/assets/js/5.215b1221.js"><link rel="prefetch" href="/MyStudyNote/assets/js/6.4a43bc5c.js"><link rel="prefetch" href="/MyStudyNote/assets/js/7.e1fcdc30.js"><link rel="prefetch" href="/MyStudyNote/assets/js/8.2815e710.js"><link rel="prefetch" href="/MyStudyNote/assets/js/9.fc0f8a39.js">
    <link rel="stylesheet" href="/MyStudyNote/assets/css/0.styles.8bcb82ca.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/MyStudyNote/" class="home-link router-link-active"><!----> <span class="site-name">八股速记</span></a> <nav class="links"><!----> <ul class="nav-links can-hide"><li class="nav-item"><a href="/MyStudyNote/" class="nav-link"><!----> <span>首页</span></a></li><li class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Lansong的八股笔记" class="dropdown-title"><!----> <span class="title">
      Lansong的八股笔记
    </span> <span class="arrow down"></span></button> <button type="button" aria-label="Lansong的八股笔记" class="mobile-dropdown-title"><!----> <span class="title">Lansong的八股笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Lansongxx" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----> <span>Github</span> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></li> <li class="nav-item"><a href="https://github.com/Lansongxx/MyStudyNote" target="_blank" rel="noopener noreferrer"><i class="fab fa-github"></i> <span>github</span> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="theme-switcher"><a class="switch light"><span><i aria-hidden="true" class="fa fa-sun"></i></span></a></div></nav></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!----> <ul class="nav-links"><li class="nav-item"><a href="/MyStudyNote/" class="nav-link"><!----> <span>首页</span></a></li><li class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Lansong的八股笔记" class="dropdown-title"><!----> <span class="title">
      Lansong的八股笔记
    </span> <span class="arrow down"></span></button> <button type="button" aria-label="Lansong的八股笔记" class="mobile-dropdown-title"><!----> <span class="title">Lansong的八股笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Lansongxx" target="_blank" rel="noopener noreferrer" class="nav-link external"><!----> <span>Github</span> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></li> <li class="nav-item"><a href="https://github.com/Lansongxx/MyStudyNote" target="_blank" rel="noopener noreferrer"><i class="fab fa-github"></i> <span>github</span> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul>  <ul class="sidebar-links"><li><a href="/MyStudyNote/handbook/操作系统.html" class="sidebar-link">操作系统</a></li><li><a href="/MyStudyNote/handbook/Redis.html" class="sidebar-link">Redis</a></li><li><a href="/MyStudyNote/handbook/Mysql.html" class="sidebar-link">Mysql</a></li><li><a href="/MyStudyNote/handbook/Kafka.html" class="sidebar-link">Kafka</a></li><li><a href="/MyStudyNote/handbook/计算机网络.html" class="active sidebar-link">计算机网络</a></li><li><a href="/MyStudyNote/handbook/MongoDB.html" class="sidebar-link">MongoDB</a></li><li><a href="/MyStudyNote/handbook/6.824.html" class="sidebar-link">6.824</a></li><li><a href="/MyStudyNote/handbook/Golang.html" class="sidebar-link">Golang</a></li></ul> </aside> <main class="page"> <div class="theme-vpx-content content__default"><h1 id="计算机网络"><a href="#计算机网络" class="header-anchor">#</a> 计算机网络</h1> <p>1.TCP/IP 网络模型有哪几层</p> <details><summary>答案</summary> <p>4层，应用层，传输层，网络层，网络接口层</p> <p>应用层提供两个终端设备上的应用程序之间信息交换的服务</p> <p>传输层负责向两台终端设备进程之间的通信提供通用的数据传输服务</p> <p>网络层负责为分组交换网上的不同主机提供通信服务</p> <p>网络接口层是数据链路层和物理层的合并，所以它的作用包括物理层的实现相邻计算机节点之间比特流的透明传送和数据链路层的将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧</p></details> <p>2.网络分层的原因</p> <details><summary>答案</summary> <p>1.各层之间相互独立：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了</p> <p>2.提高了整体灵活性：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。</p> <p>3.分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。</p></details> <p>3.从输入 URL 到页面展示到底发生了什么？</p> <details><summary>答案</summary> <p>首先会先解析URL，然后根据域名通过DNS解析协议解析出IP地址，DNS解析会先发送给本地域名服务器，本地域名服务器会查看本地的缓存列表，如果没有就向根域名服务器发起DNS解析请求，根域名服务器不负责解析，根域名服务器会告诉本地域名服务器负责该域名的顶级域名服务器的IP地址，然后本地域名服务器向该顶级域名服务器发起DNS解析请求，顶级域名服务器会告诉本地域名服务器负责该域名的权威域名服务器的地址，然后本地域名服务器会向该权威域名服务器发起DNS解析请求，权威域名服务器会告诉本地域名服务器该域名的IP地址。拿到该IP地址后，封装成HTTP请求报文，交付给传输层，到了传输层后，要先三次握手建立连接，建立好连接后，会加上TCP首部然后交付给网络层，网络层负责分组转发和确定分组从源到目的经过的路径，然后添加上IP首部，交付给网络接口层，网络接口层要确定数据报要发给谁，需要通过ARP协议获取目标服务器的MAC地址，ARP协议会在以太网中广播，请求获取下一步要发给的MAC地址，获取到后，将对应的MAC地址缓存下来，然后给数据报添加帧头和帧尾，然后通过网卡，交换机，路由器最终到达目标服务器</p></details> <p>4.HTTP是什么？ 目前没有很好的答案</p> <details><summary>答案</summary> <p></p></details> <p>5.HTTP常见状态码</p> <details><summary>答案</summary> <p>
        200请求成功一切正常，响应头包含body数据,204也是请求成功，但响应头没有body数据，206用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分
    </p> <p>
        301表示永久重定向，表明请求的资源已经不存在了，302表示临时重定向，请求的资源还在，但暂时需要使用另外的url来访问,304表示资源未修改，用于告诉客户端可以继续使用缓存资源
    </p> <p>
       400表示客户端请求的报文有误，401表示服务器禁止访问资源，404表示请求的资源在服务器不存在或未找到
    </p> <p>
        500表示服务器内部错误，501表示客户端请求的功能还不支持，502表示网关错误，503表示服务器正忙，无法响应客户端
    </p></details> <p>6.GET 和 POST 有什么区别？</p> <details><summary>答案</summary> <p>1.用途不同：Get是用来从服务器上获得数据，而 Post是用来向服务器上传递数据。</p> <p>2.Get是不安全的，因为Get会将请求参数放在URL中，而Post则不会</p> <p>3.Get能够传输的数据量，因为Get会受到url长度的限制，而Post则不会</p> <p>4.Get能被缓存而Post则不能被缓存</p> <p>5.Post首部字段更多，所以Post会更慢</p></details> <p>7.HTTP 和 HTTPS 有什么区别？</p> <details><summary>答案</summary> <p>1.HTTP是明文传输，HTTPS则在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输</p> <p>2.默认端口不同，HTTP默认端口是80，HTTPS默认端口是443</p> <p>3.HTTP连接建立更加简单，HTTPS还需要进行SSL/TLS握手，才能进行加密传输</p></details> <p>8.HTTP1.0和HTTP1.1的区别</p> <details><summary>答案</summary> <p>1.HTTP1.0为短连接，HTTP1.1支持长连接</p> <p>2.HTTP1.1增加了大量的状态响应码</p> <p>3.HTTP1.1引入了更多的缓存控制策略，提供了更多可选择的缓存头</p> <p>4.HTTP1.1支持管道网络传输，只要第一个请求发送出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间</p></details> <p>9.HTTP1.1的缺陷</p> <details><summary>答案</summary> <p>1.HTTP1.1的请求和响应头部未经压缩就发送，导致发送延迟比较大</p> <p>2.发送冗长的首部。每次互相发送相同的首部造成的浪费较多</p> <p>3.服务器是按请求的顺序发送响应的，如果服务器响应慢，会导致客户端一直请求不到数据，即可后面的请求已经处理好了，也无法发出响应，也就是队头阻塞</p> <p>4.请求只能从客户端开始，服务器只能被动响应</p></details> <p>10.HTTP2.0和HTTP1.1的区别</p> <details><summary>答案</summary> <p>1.HTTP2.0采用了头部压缩，对于头部中相同的部分使用一个索引号代替，使用HPACK算法维护了一张头信息表</p> <p>2.HTTP2.0不再采用纯文本的形式，而是采用二进制的形式，增加了传输效率</p> <p>3.HTTP2.0引入了stream的概念，一个TCP连接包含多个stream，一个stream包含一个或多个Message，一个Message包含一个或多个Frame，Fream是HTTP2.0的最小单位，不同stream可以乱序发送</p> <p>4.HTTP2.0改善了请求-响应模式，客户端和服务器都可以建立stream,服务器可以给客户端推送数据</p></details> <p>11.HTTP2.0的缺陷</p> <details><summary>答案</summary> <p>1.HTTP2.0虽然采用了stream模式，但是还是存在队头阻塞，因为stream是基于TCP的，后面的stream即使到达了，应用层也无法读取，需要按序读取stream</p> <p>2.一旦发生丢包，该TCP连接的所有HTTP请求都要等待该包重传</p></details>
12.HTTP3.0和HTTP2.0的区别
<details><summary>答案</summary> <p>1.HTTP3.0实现了无队头阻塞，当某个流发生丢包时，只会阻塞这个流，其他流不会受影响</p> <p>2.HTTP3.0采用了QUIC协议，能够更快的建立连接，握手过程只需要1个RTT</p> <p>3.HTTP3.0实现了连接迁移，因为QUIC采用的并不是四元组来确定一条连接，而是通过连接ID来标记通信的两个端点，即使网络连接发生变化，上下文信息不变，可以无缝的复用原连接</p></details> <p>13.什么是强制缓存和协商缓存</p> <details><summary>答案</summary> <p>强制缓存是指只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，通过cache-control和expires实现，cache-control表示过期的相对时间，expires表示过期的绝对时间</p> <p>协商缓存是指与服务端协商之后，通过协商结果来判断是否使用本地缓存，</p></details>
14.TCP是什么？
<details><summary>答案</summary> <p>
        TCP是面向连接，可靠的，基于字节流的传输层通信协议
        面向连接是指在进行数据传输之前必须建立连接
        可靠的是指TCP能保证数据能够完整，准确的从发送方传输到接收方
        基于字节流是指TCP传输的数据是一连串的无结构的字节流
    </p></details> <p>15.有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</p> <details><summary>答案</summary> <p>
        客户端IP数*客户端端口号=2^32*2^16.这是理论最大限制，但是会受到服务器内存限制，文件描述符限制
    </p></details> <p>16.UDP 和 TCP 有什么区别呢？</p> <details><summary>答案</summary> <p>1.连接：TCP是面向连接的，传输数据之前要建立连接。UDP是不需要连接的，即立刻传输数据</p> <p>2.服务对象：TCP是一对一的两点服务，UDP支持一对一，一对多，多对多的交互通信</p> <p>3.可靠性：TCP是可靠交付数据的，数据可以无差错，不丢失，不重复，按序到达。而UDP是尽最大努力交付的，不保证可靠交付数据</p> <p>4.拥塞控制、流量控制:TCP有拥塞控制和流量控制机制，保证数据传输的安全性。UDP则没有，即可网络非常拥挤了也不会影响UDP的发送速率</p> <p>5.首部开销：TCP首部较长，会有一定的开销UDP首部只有8个字节，开销较小</p> <p>6.传输方式：TCP是流式传输，没有边界，但保证顺序和可靠。UDP是一个包一个包的传输，是有边界的，但可能丢包和失序</p></details> <p>17.TCP和UDP的应用场景</p> <details><summary>答案</summary> <p>
        TCP通常用于HTTPS/HTTP，FTP,SSH等场景
        UDP通常用于DNS,广播通信，视频，音频等多媒体通信
    </p></details> <p>18.TCP 和 UDP 可以使用同一个端口吗？</p> <details><summary>答案</summary> <p>可以，在内核中TCP和UDP是两个完全独立的模块</p></details> <p>19.TCP 三次握手过程</p> <details><summary>答案</summary> <p>首先客户端和服务端都处于close状态，服务端会主动监听某个端口，处于listen状态，客户端会初始化一个随机序列号，将该序列号置于TCP首部的序号字段中，同时将SYN标志位设置为1，表示SYN报文，然后发送给服务端，之后客户端进入syn-sent状态。
    </p> <p>服务端收到SYN报文后，也初始化一个随机序列号,将该序列号置于TCP首部的序号字段中，将TCP首部的确认号字段的值设置为SYN报文TCP首部中序号的值+1，同时将SYN和ACK标志位设置为1，发送给客户端，之后服务端进入sync-rcvd
    </p> <p>客户端收到服务端的报文后，还需要发送一个确认报文，该确认报文TCP首部确认号字段的值设置为服务端报文TCP首部的序列号+1，同时将ACK标志位设置为1，发送给服务端，之后客户端进入ESTABLISHED状态,服务端收到客户端的应答报文后，也进入ESTABLISHED状态
    </p></details> <p>20.TCP为什么要三次握手？</p> <details><summary>答案</summary> <p>
        主要原因是三次握手才可以阻止重复历史连接的初始化，还有三次握手才可以同步双方的初始序列号,三次握手能够减少资源开销（因为如果采用两次握手时，如果SYN报文阻塞，然后客户端重发SYN报文会导致建立多个无用的连接，浪费资源）
    </p></details> <p>21.TCP为什么要随机生成初始序列号</p> <details><summary>答案</summary> <p>
        1.为了防止历史报文被下一个相同的四元组接收
        2.防止黑客伪造相同序列号的TCP报文被对方接收
    </p></details> <p>22.在IP层会分片，为什么TCP层还需要MSS呢？</p> <details><summary>答案</summary> <p>
        因为如果在IP层进行分片的话，由于IP层没有超时重传机制，所以会导致一个分片丢失，全部分片重传
    </p></details> <p>23.什么是SYN攻击？如何避免SYN攻击</p> <details><summary>答案</summary> <p>通过短时间内伪造不同ip地址的syn报文，从而使得服务端的半连接队列被占满，使得客户端不能为正常用户提供服务</p> <p>
        1.增大半连接队列
        2.减少SYN-ACK重传次数
        3.启用syncookies
	4.调大netdev_max_backlog参数
    </p></details> <p>24.TCP四报文挥手</p> <details><summary>答案</summary> <p>首先客户端打算关闭连接，会发送一个FIN报文，该报文的TCP首部中的FIN字段设置为1，发送给服务端，之后客户端进入time_wait_1状态。服务端收到该报文后向客户端发送ACK应答报文，之后服务端进入close_wait状态。客户端收到服务端的ACK应答报文后，进入time_wait_2状态。等待服务端处理完数据后，向客户端发送FIN报文，之后进入last_ack状态。客户端收到服务端的FIN报文后，发送一个ACK应答报文给服务端，然后进入time_wait状态。服务端接收到客户端的ACK应答报文后，进入close状态，自此服务端的连接已经关闭。等待2MSL后，客户端也自动进入close状态，自此客户端的连接已经关闭</p></details> <p>25.为什么要进行四报文挥手</p> <details><summary>答案</summary> <p>
        因为服务端在收到FIN-ACK报文时，可能还有需要发送和处理的数据，需要等待服务端处理和发送完数据后才会发送FIN报文给客户端表示同意关闭连接
    </p></details> <p>26.为什么TIME_WAIT是2MSL</p> <details><summary>答案</summary> <p>MSL是最大报文生存时间，等待2MSL可以保证第四次挥手报文被服务端接收，如果没有接收，在2MSL之前也会收到服务端重传的FIN报文，然后重新等待2MSL</p></details> <p>27.为什么需要 TIME_WAIT 状态？</p> <details><summary>答案</summary> <p>
        1.防止历史连接的数据，被后面相同四元组的连接错误的接收
        2.保证被动关闭的一方，能被正确的关闭
    </p></details> <p>28.TIME_WAIT过多有什么危害？</p> <details><summary>答案</summary> <p>
        1.占用系统资源
        2.占用端口资源
    </p></details> <p>29.大量TIME_WAIT的原因</p> <details><summary>答案</summary> <p>
        1.HTTP没有启用长连接
        2.HTTP长连接超时
        3.HTTP长连接的请求数量达到上限
    </p></details> <p>30.大量CLOSE_WAIT的原因</p> <details><summary>答案</summary> <p>
        1.没有将服务端socket注册到epoll
        2.新连接到来时，没有调用accept获取该连接的socket
        3.accept获取已连接的socket后，没有将其注册到epoll
        4.客户端关闭连接后，服务端没有调用close函数
    </p></details> <p>31.如果已经建立了连接，但是客户端突然出现故障了怎么办？</p> <details><summary>答案</summary> <p>
        TCP通过保活机制会每隔一段时间发送探测报文，如果连续几个探测报文都没有得到相应，则会认为该TCP连接已经死亡。
        如果对端主机正常，将会重置保活时间，如果对端主机宕机，发送几次探测报文后，会报告该TCP连接已经死亡。如果对端主机宕机并重启，对端会产生一个RST报文，重置该连接
    </p></details> <p>32.如果已经建立了连接，但是进程崩溃了怎么办？</p> <details><summary>答案</summary> <p>
        当进程崩溃后，操作系统内核会自己完成四次挥手
    </p></details> <p>33.socket和TCP的关系</p> <details><summary>答案</summary> <p>
        在三次握手中，服务端和客户端首先初始化socket，然后服务端调用bind,listen，然后调用accept阻塞，然后客户端调用connect,此时会进行三次握手，第二次握手后，connect会返回，第三次握手完成后会将连接的socket放入accept队列，然后此时accpet函数返回一个已连接的socket,然后调用read读数据阻塞，客户端调用write写数据，当读到EOF时，调用close。
        在四报文挥手时，首先客户端调用close，然后第一次挥手会将EOF写入接收缓冲区，然后当read读到EOF调用close进行第三次挥手 
    </p></details> <p>34.没有 listen，能建立 TCP 连接吗</p> <details><summary>答案</summary> <p>
        可以，只要两个客户端同时调用connect即可
    </p></details> <p>35.没有 accept，能建立TCP连接吗</p> <details><summary>答案</summary> <p>
        可以，accept只是从accpet队列中取出一个socket,并不参与三次握手
    </p></details>
36.TCP的重传机制
<details><summary>答案</summary> <p>
        1.超时重传：发送数据时会设置一个定时器，当超过指定时间后，没有收到对方的ACK确认应答报文，就会重发该数据。
    </p> <p>
        2.快速重传：当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
    </p> <p>
        3.SACK：通过在TCP首部的选项字段添加SACK，将已收到的数据的信息发送给发送方，使得发送方可以只重传丢失的数据
    </p> <p>
        4.D-SACK：通过使用SACK告诉发送方那些数据被重复接收了。可以让发送方知道是发送出去的数据包丢了，还是接收方回应的ACK丢了
    </p></details> <p>37.TCP的滑动窗口</p> <details><summary>答案</summary> <p>
       滑动窗口分为发送窗口和接收窗口，发送窗口通过记录已发送但未收到ACK应答的第一个字节的位置，待发送但还接收方还可以处理的第一个字节的位置，未发送并且接收方不可以处理的第一个字节的位置
        接收窗口通过记录未接收但还可以接收的第一个字节的位置，未接收并且不可以接收的第一个字节的位置
        发送窗口的大小约等于接收窗口的大小，因为大小同步是有时延的
    </p></details> <p>38.TCP流量控制的原理</p> <details><summary>答案</summary> <p>
        TCP流量控制通过滑动窗口和调整TCP报文的大小来实现。
        通过滑动窗口协调发送窗口和接收窗口的大小来使得发送方的发送速率不要太快，要让接收方来得及接收
        因为TCP首部就有20个字节，所以需要避免发送太小的报文。所以通过控制TCP报文的大小，达到一定大小才能发送
    </p></details>
39.TCP的拥塞控制
<details><summary>答案</summary> <p>
        通过维护一个拥塞窗口的大小来避免发送方填满整个网络
        拥塞控制有四种算法
    </p> <p>
        慢启动算法，刚建立TCP连接的时候，每收到一个ACK，拥塞窗口的大小就翻倍，当到达慢启动门限时，就会启用拥塞避免算法
    </p> <p>
        拥塞避免算法: 当拥塞窗口超过慢启动门限时，每收到一个ACK，拥塞窗口就增加1/cwnd(拥塞窗口大小)
    </p> <p>
        拥塞发生算法：当遇到超时重传的时候 ，拥塞窗口大小会设置为1，慢启动门限会设置为原来的一半,当遇到快速重传(即三个重复的ACK)，拥塞窗口会设置为原来的一半，慢启动门限设置为拥塞窗口的一半
    </p> <p>
        快速恢复算法: 当遇到快速重传时，会将拥塞窗口设置为原来的一半再加3，慢启动门限设置为拥塞窗口的一半，3表示已经确认接收到3个重复的ACK，如果再收到重复的ACK，拥塞窗口+1，如果收到新数据的ACK，则将拥塞窗口的大小设置为慢启动门限
    </p></details>
40.为什么有了流量控制，还要拥塞控制？
<details><summary>答案</summary> <p>
        流量控制是为了避免发送方的数据填满接收方的缓存
        拥塞控制是为了避免发送方的数据填满整个网络
    </p></details>
41.TCP的全连接队列和半连接队列
<details><summary>答案</summary> <p>
        服务端收到客户端的SYN请求后，内核会将该连接存储到半连接队列中，并响应SYN+ACK，客户端会返回ACK，当服务器收到第三次握手的ACK时，内核会将该连接从半连接队列中移除，然后创建新的完全的连接，将其添加到全连接队列，等待调用accept时将其取出
    </p></details> <p>42.当全连接队列和半连接队列满了会怎么样？</p> <details><summary>答案</summary> <p>
        当全连接队列满了后，会将后续的请求丢弃，或者回复RST报文
        当半连接队列慢了后，如果没有开启syncookies，将会丢弃，如果全连接队列满了并且需要重传SYN+ACK的包多余一个，也会将其丢弃，如果没有开启syncookies并且当前半连接队列的长度超过max_syn_backlog的3/4
    </p></details> <p>43.半连接队列和全连接队列的最大长度?</p> <details><summary>答案</summary> <p>
        全连接队列的最大长度为min(somaxconn,max_syn_backlog)
        半连接队列的理论最大长度为全连接队列最大长度和max_syn_backlog最小值的两倍
        实际的最大长度还会受到一个条件的限制，还要与max_syn_backlog的3/4取min
    </p></details> <p>44.什么情况下SYN包会被丢弃</p> <details><summary>答案</summary> <p>
        1.NAT网络下，开启tcp_tw_recycle参数(因为NAT下不同的主机，会被看作相同的IP地址，因为开启了recycle+timestamp他并不会对四元组做检查，而是对IP地址做检查，就会使得改SYN包被丢弃)
        2.半连接队列满了并且没有开启syncookies，全连接队列满了并且需要重传syn+ack的连接超过1个，当前半连接队列的长度超过tcp_max_backlog的3/4
    </p></details> <p>45.已经建立连接的TCP，收到一个SYN包会怎么办?</p> <details><summary>答案</summary> <p>
        1.如果这个SYN包的端口号和历史连接的端口号不同，则会被认为是建立一个新的连接，然后旧的连接，服务端会启用tcp保活机制，最后会将其释放掉
        2.如果这个SYN包的端口号和历史连接的端口号相同，因为这个序列号是随机的，所以服务端会回复一个正确的序列号和ACK，客户端收到发现不是自己期望的ACK，会回一个RST报文，从而释放该连接
    </p></details> <p>46.TCP如何处理乱序的数据？</p> <details><summary>答案</summary> <p>
        当收到乱序的数据时，会将其加入到乱序队列中，然后当延迟的数据到达后，会检查乱序队列中是否有能够接上的数据，如果有，判断是否带有FIN标志，如果有，则将其进行处理
    </p></details> <p>47.处于TIME_WAIT状态时，收到SYN会发生什么</p> <details><summary>答案</summary> <p>
        首先会判断是否为合法的SYN，如果是，则会跳过TIME_WAIT状态，直接进入syn_recv状态
        如果是不合法的SYN，则会回一个之前的ACK，对方收到后，收到的不是自己期望的ACK，则会发送RST报文
    </p></details> <p>48.处于TIME_WAIT状态时，收到RST报文会直接关闭吗？</p> <details><summary>答案</summary> <p>
        取决于net.ipv4.tcp_rfc1337参数，如果设置为0，则提前结束TIME_WAIT状态，释放连接，如果设置为1，则会丢弃该RST报文
    </p></details> <p>49.TCP连接中遇到主机崩溃和进程崩溃会怎么样？</p> <details><summary>答案</summary> <p>
        如果进程崩溃，最终内核会完成四次挥手
        如果主机崩溃，如果没有数据交换，如果没有开启keepalive，那么服务端将会一直等待，如果开启了keepalive，再探测到对方已经崩溃后将会关闭该连接
                     如果有数据交换，如果主机崩溃后迅速重启，将会回复RST报文，关闭该连接。如果主机崩溃后没有重启，服务端重传超过一定次数后，最终也会关闭该连接
    </p></details> <p>50.为什么tcp_tw_reuse是默认关闭的？</p> <details><summary>答案</summary> <p>
        首先，开启tcp_tw_reuse就必须开启timestamp，然而这样会导致收到历史报文时，如果是RST报文，不会被丢弃
        其次，还可能导致对方无法接收到第四次挥手的ACK报文，从而导致被动关闭连接的一方被不正常的关闭。
    </p></details> <p>51.TCP握手和TLS握手能同时进行吗？</p> <details><summary>答案</summary> <p>
        可以，但是必须保证客户端和服务端双方启用tcp fast open并且tls版本为1.3，并且之前已经建立连接
    </p></details> <p>52.HTTP的keep-alive和TCP的keepalive是同一个东西嘛</p> <details><summary>答案</summary> <p>
        不是,HTTP的keep-alive是应用层实现的，是HTTP的长连接
        TCP的keepalive是传输层实现的，是TCP的保活机制
    </p></details> <p>53.TCP有什么缺陷?</p> <details><summary>答案</summary> <p>1.TCP是在内核实现的，应用程序只能使用而不能修改，因为如果想要升级TCP协议，就只能升级内核，所以使得TCP的升级工作很困难</p> <p>2.TCP连接建立的延迟，基于应用层的协议，都需要先进行三次握手才能传输数据，大多数使用HTTPS的，在建立TCP连接后，还需要进行TLS握手，增大了数据传输的延迟</p> <p>3.TCP存在队头阻塞的问题，因为TCP是字节流协议，TCP层必须保证收到的字节数据是有序的，后面的字节数据即使收到了也无法从内核中读取数据</p> <p>4.网络迁移需要重新建立连接：因为TCP是根据四元组来确定一条TCP连接的，所以一旦网络发生变化，IP地址就会发生变化，就需要重新建立连接</p></details> <p>54.如何基于UDP实现可靠传输</p> <details><summary>答案</summary> <p>
        1.基于UDP实现的可靠传输已经有了，QUIC协议，QUIC是通过Package Number 和Stream ID,Offset，可以支持序确认而不影响数据包的正确组装
        2.Stream级别的流量控制，每个stream有独立的接收窗口，即使一个窗口无法移动，也不会影响其他的Stream
        3.Connection级别的流量控制：他的接收窗口是所有stream之和
        4.QUIC对TCP的拥塞控制进行了改进，因为QUIC是处于应用层的，所以不同应用程序可以设置不同的拥塞控制算法
        5.QUIC支持更快的连接建立，通过连接ID来标识一个连接，即使网络发生变化，只要上下文信息还在，就可以复用原来的连接
        6.QUIC还解决了TCP队头阻塞的问题。QUIC为每个stream都分配了一个滑动窗口，使得多个stream之间没有依赖关系，相互独立
        7.QUIC建立连接的速度更快，QUIC内部包含了TLS，并且使用的是TLS1.3，QUIC自己的帧中就包含了TLS的记录，从而使得建立连接只需要1RTT，第二次连接只需要0RTT
    </p></details> <p>55.QUIC是如何解决TCP队头阻塞问题的？</p> <details><summary>答案</summary> <p>
        QUIC对每个不同的stream都有一个滑动窗口，各个stream之间没有依赖关系，相互独立
    </p></details> <p>56.QUIC是如何迁移连接的？</p> <details><summary>答案</summary> <p>
        使用连接ID来标记通信的两个端点，从而使得网络发生变化时，只需要仍保有上下文信息，就可以复用原来的连接
    </p></details>
57.客户端的端口可以重复使用吗？
<details><summary>答案</summary> <p>
        只要不是相同的目的ip+目的端口就可以重复使用
    </p></details> <p>58.如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？</p> <details><summary>答案</summary> <p>开启net.ipv4.tcp_tw_reuse参数，对于相同的四元组，处于TIME_WAIT状态并且超过1秒，可以直接复用该连接</p></details> <p>59.如果服务端没有listen，客户端建立连接会怎么样？</p> <details><summary>答案</summary> <p>
        因为服务端没有listen，所以无法找到对应的socket，所以会回复一个RST报文
    </p></details> <p>60.用了TCP，数据一定不会丢失吗？</p> <details><summary>答案</summary> <p>
        不一定。数据丢失有以下几种情况.1.半连接，全连接队列满了，导致连接建立失败
        2.流量控制丢包，为了控制进入网卡的流量，在网络层有个队列，队列满了会导致丢包
        3.网卡丢包：网线质量差
        4.RingBuffer过小导致丢包：因为发送数据速度过快，数据还没有被内核读取就被覆盖，从而导致丢包
    </p></details> <p>61.TCP四次挥手可以变成三次挥手吗？</p> <details><summary>答案</summary> <p>
        可以，但是得满足没有数据要发送并且开启了TCP延迟确认机制，这样第二次握手的ACK不会立马发送，而是等FIN一起发送
    </p></details></div> <div class="page-edit"><!----> <span class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2024/2/26 11:02:09</span></span></div> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/MyStudyNote/handbook/Kafka.html" class="prev">
        Kafka
      </a></span> <span class="next"><a href="/MyStudyNote/handbook/MongoDB.html">
        MongoDB
      </a>
      →
    </span></p></div> <div class="page-footer"><ul class="inner"><li>Theme by <a href="https://gitee.com/qcyblm/vuepress-theme-vpx" title="本站主题" target="_blank" rel="noopener noreferrer">VPX</a></li> <li>Powered by <a href="https://www.vuepress.cn/" target="_blank" rel="noopener noreferrer">VuePress</a></li> <!----> <li>
      Copyright © 2024
      <a href="https://windliang.wang" target="_blank" rel="noopener noreferrer"> Lansong </a></li> <li><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer"><!---->  
      </a></li> </ul></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/MyStudyNote/assets/js/app.9d2cd43a.js" defer></script><script src="/MyStudyNote/assets/js/2.7df07032.js" defer></script><script src="/MyStudyNote/assets/js/13.699ad82a.js" defer></script>
  </body>
</html>
