# Redis

## 1.Redis是什么？
<details>
    <summary>答案</summary>
    <p>Redis是基于内存的数据库，读写操作都在内存中完成,因此读写速度特别快，常用于缓存，消息队列</p>
</details>

## 2.Redis和MemCached的区别
<details>
    <summary>答案</summary>
    <p>1.Redis支持的数据类型跟丰富，如Hash,List,Set,ZSet等，而MemCached只支持字符串</p>
    <p>2.Redis支持数据的持久化，可以将内存中的数据存储在磁盘中，重启的时候可以再次加载使用，而MemCached不支持持久化，数据全部存储在内存中，一旦重启或挂掉后，数据就丢失了。</p>
    <p>3.Redis支持原生的集群模式，MemCached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</p>
    <p>4.Redis支持订阅，Lua脚本，事务等功能，而MemCached不支持</p>
</details>

## 3.Redis常用数据类型及其应用场景
<details>
    <summary>答案</summary>
    <p>1.String 用于缓存对象，计数器，分布式锁，共享Session</p>
    <p>2.List 用于消息队列(但是需要自己实现全局唯一ID,不能以消费组的形式消费数据)</p>
    <p>3.Set 用于共同好友，点赞等场景</p>
    <p>4.ZSet 用于排行榜</p>
    <p>5.BitMap 常用于签到，用户登陆状态判断</p>
    <p>6.HyperLogLog 常用于大量数据的基数统计，例如网页浏览量统计</p>
    <p>7.GEO 用于地理位置信息存储，例如滴滴叫车，附近的人</p>
    <p>8.Stream 用于消息队列，支持消费组和自动生成全局唯一ID</p>
</details>

## 4.Redis是单线程的吗?
<details>
    <summary>答案</summary>
    <p>我们常说的Redis是单线程的是指接收客户端请求，解析请求，进行数据读写操作，发送数据给客户端这个过程是由一个线程完成。但Redis并不是但线程的，它还为关闭文件，AOF刷盘，释放内存任务创建了后台线程</p>
</details>

## 5.Redis6.0之前为什么使用单线程
<details>
    <summary>答案</summary>
    <p>单线程是无法利用多核CPU的，但是Redis仍然采用单线程模型，因为Redis是基于内存的，读写速度很快，所以性能瓶颈不在CPU，而在于内存和网络IO，并且使用单线程可以提高可维护性，多线程模型虽然在某些方面表现优秀，但是也导致了一些并发读写带来的问题，增加了系统的复杂度。</p>
</details>

## 6.为什么Redis6.0后引入了多线程
<details>
    <summary>答案</summary>
    <p>因为随着网络硬件的提升，Redis的性能瓶颈有时会出现在网络IO处理上，所以使用了多个IO线程来处理网络请求，但是对于命令的执行，仍然采用单线程来处理</p>
</details>

## 7.AOF日志的原理
<details>
    <summary>答案</summary>
    <p>先执行写操作，再将日志写入AOF缓冲区（因为这样可以避免额外的检查开销，还不会阻塞当前的写操作），等到系统调用write时再写入内核缓冲区，然后由内核发起写操作，写入磁盘</p>
</details>

## 8.AOF日志重写的原理
<details>
    <summary>答案</summary>
    <p>当AOF日志过大时，会触发AOF重写，Redis会开启一个子进程, 读取数据库中的所有键值对，然后每一个键值对用一条名录记录到新的AOF文件，AOF重写期间，主进程可以继续处理命令请求，主进程产生的AOF日志先写入AOF缓冲区，再写入AOF重写缓冲区。完成重写工作后，会向主进程发送一条命令，然后主进程会将AOF重写缓冲区的所有内容追加到新的AOF文件中，然后将新的AOF文件改名，覆盖旧的AOF文件</p>
</details>

## 9.为什么AOF日志重写要用子进程而不是线程
<details>
    <summary>答案</summary>
    <p>因为如果使用线程，多线程之间会共享内存，修改共享内存数据时需要加锁，从而会降低性能。而使用子进程，父子进程共享数据，当内存发生修改时，会发生写时复制，而不需要加锁</p>
</details>

## 10.RDB快照原理
<details>
    <summary>答案</summary>
    <p>Redis生成RDB快照有两种方式</p>
    <p>一种是save，在主线程生成RDB文件，如果生成RDB文件时间过长就会阻塞主线程</p>
    <p>一种是bgsave，会创建一个子进程来生成RDB文件，可以避免阻塞主线程。Redis的RDB快照是全量快照，每次执行快照会把内存中的所有数据都记录到磁盘中，所以频率不能太频繁</p>
</details>

## 11.混合持久化
<details>
    <summary>答案</summary>
    <p>开启混合持久化后，AOF重写时，子进程会将共享的AOF日志以RDB的形式写入到新的AOF文件中，重写完成后通知主进程，主进程将AOF重写缓冲区以AOF的形式追加到新的AOF文件，然后将新的AOF文件改名，覆盖旧的AOF文件</p>
</details>

## 12.AOF，RDB，混合持久化优缺点
<details>
    <summary>答案</summary>
    <p>AOF的文件体积更大，性能较差，恢复速度较慢，但是AOF丢失的数据更少</p>
    <p>RDB的文件体积跟小，性能较高，恢复速度较快，但是RDB丢失的数据更多</p>
    <p>混合持久化有RDB的优点恢复速度快，也有AOF的优点丢失的数据少，同时也有其缺点，可读性跟差，兼容性更差</p>
</details>

## 13.Redis主从复制原理
<details>
    <summary>答案</summary>
    <p>一开始，从节点向主节点建立连接，然后主节点生成RDB快照，将其发送给从节点，从节点清空自己的数据，然后载入RDB快照，在生成RDB快照的过程中，不会阻塞的主进程，期间的写操作命令记录在replication buffer内。在从节点加载RDB快照完成后，主节点将replication buffer中的数据发送给从节点</p>
    <p>当从节点掉线重连后，主节点会采用增量复制的方式发送数据，首先会检查要发送的数据是否存在repl_backlog_buffer（在发送给从节点之前会先将命令写入这里）中，如果在则进行增量复制，否则进行全量复制</p>
</details>

## 14.Redis哨兵模式原理
<details>
    <summary>答案</summary>
    <p>哨兵一开始会监控主节点的状态，如果Ping不通主节点，则判定为主观下线，然后向其他哨兵发送命令，其他哨兵节点根据自身与主节点的网络状态，投出赞成或反对，如果赞成票数达到quorum值，则判定主节点为客观下线。然后通知其他哨兵，希望成为leader来进行主从切换，每个哨兵只有一次投票机会，如果得到半数以上的赞成票并且大于等于quorum值，则当选leader。开始主从切换，在从节点中选出一个节点将其转化为主节点（选取规则：先过滤掉网络不好的，然后优先级，复制下标，节点ID排序），然后通知其他从节点更换复制目标，将新主节点的信息发送给客户端，继续监视旧主节点，当他上线后设置为新节点的从节点。</p>
</details>

## 15.Redis集群原理
<details>
    <summary>答案</summary>
    <p>Redis集群将所有数据自动分成16384个哈希槽，将数据分散在不同的节点上。节点之间基于Gossip协议进行通信，通过主从复制和故障转移保证高可用</p>
</details>

## 16.Redis过期删除策略
<details>
    <summary>答案</summary>
    <p>Redis的过期删除策略由惰性删除和定期删除组成，惰性删除是指当访问到某个key时，判断是否过期，如果过期了就将其删除，否则不做处理。而定期删除是指每隔一段随机抽取20个key，将过期的key删除，如果定期删除执行时间超过了25ms，那么直接结束，否则判断过期key是否超过25%，超过则继续抽取</p>
</details>

## 17.Redis内存淘汰策略
<details>
    <summary>答案</summary>
    <p>1.随机淘汰设置了过期时间的key</p>
    <p>2.优先淘汰更早过期的key</p>
    <p>3.淘汰设置了过期时间中的，最久未使用的key</p>
    <p>4.淘汰设置了过期时间中的，最少使用的key</p>
    <p>5,随机淘汰key</p>    
    <p>6.淘汰最久未使用的key</p>
    <p>7.淘汰最少使用的key</p>
</details>

## 18.Redis的LRU和LFU
<details>
    <summary>答案</summary>
    <p>Redis的LRU算法和传统的LRU算法不同，Redis通过添加最后访问时间的字段，然后需要淘汰数据时，通过随机采样，然后淘汰最久没用使用的那个</p>
    <p>Redis的LFU算法记录和该key上次访问的时间戳和访问频次，每次访问时，首先会根据当前与上次访问时间的距离对访问频次进行衰减，然后按照一定概率增加访问频次的值。当需要淘汰数据时，随机抽取一些key，然后删除掉访问频次最低的key</p>
</details>

## 19.缓存雪崩、缓存击穿、缓存穿透
<details>
    <summary>答案</summary>
    <p>缓存雪崩是指大量缓存在同一时间过期，此时大量的请求直接访问数据库，从而导致数据库宕机。避免的方法是随机生成过期时间或者设置为不过期</p>
    <p>缓存击穿是指热点数据过期，此时有大量的请求访问该热点数据，从而导致大量请求直接访问数据库，导致数据库宕机。避免的方法是将热点数据设置为不过期，由后台异步更新缓存或者在热点数据快过期时，提前通知后台线程更新缓存以及重新设置过期时间。或者在加互斥锁，保证同一时间只有一个线程请求缓存，其他线程等待或返回空值</p>
    <p>缓存穿透是指大量请求即不在缓存又不在数据库中的数据，从而使得数据库宕机。避免的办法是对于在数据库中没查到的数据回种空值或默认值。或者使用布隆过滤器快速判断数据是否存在，来减少对数据库的查询。</p>
</details>

## 20.常见的缓存更新策略
<details>
    <summary>答案</summary>
    <p>1.旁路缓存。在更新数据时，先修改数据库，再删除缓存。在查询数据时，先查询缓存，再查询数据库，再将数据写回缓存</p>
    <p>2.写穿/读穿。在更新数据时，如果存在缓存，则修改缓存，由缓存组件将数据同步更新到数据库，否则直接修改数据库。在查询数据时，如果存在缓存则直接返回，否则由缓存组件从数据库查询数据，并写入缓存，然后返回</p>
    <p>3.写回。在更新数据时，只更新缓存，同时将缓存数据设置为脏，然后返回。异步的将缓存中的数据更新到数据库</p>
</details>

## 21.Redis 的大 key 如何处理
<details> 
    <summary>答案</summary>
    <p>1.分批次删除，对于一个大key，每次只删除key对应的部分数据</p> 
    <p>2.异步删除，使用unlink命令异步删除</p> 
</details>

## 22.如何用 Redis 实现分布式锁的？
<details>
    <summary>答案</summary>
    <p>通过Redis的SetNX实现，如果不存在则插入成功，如果存在，则插入失败，很适合分布式锁的加锁和解锁</p>
</details>

## 23.惰性删除和定期删除的优缺点
<details>
    <summary>答案</summary>
    <p>惰性删除不会占用太多的系统资源对CPU友好，但是会导致过期key长期占用内存得不到释放，造成一定的空间浪费。</p>
    <p>定期删除的优点是能够减少对系统资源的占用的同时还能够减少对内存空间的无效占用,但是效果不如定时删除好</p>
</details>

## 24.Redis实现的分布式锁，如果获取到锁的线程挂了怎么办
<details>
    <summary>答案</summary>
    <p>设置锁的超时时间即可</p>
</details>

## 25.Redis分布式锁容灾问题，如果一个Redis挂了会不会重复拿到这个锁
<details>
    <summary>答案</summary>
    <p>存在这种可能，如果采用的是主从或者哨兵模式的话，在主节点申请到锁后，主节点挂了，加锁信息还没来得及同步到从节点，是可以重复加锁的</p>
</details>

## 26.Redis如何解决集群情况下分布式锁的可靠性？
<details>
    <summary>答案</summary>
    <p>使用Redlock，客户端向多个独立的Redis加锁，如果能够和半数以上的节点成功的完成操作，则认为加锁成功</p>
</details>

## 27.主从模式下，如何处理过期键
<details>
    <summary>答案</summary>
    <p>从节点不会让key过期，主节点发现key过期后，会发送删除命令给从节点</p>
</details>

## 28.为什么Redis集群采用哈希槽而不是一致性哈希
<details>
    <summary>答案</summary>
    <p>1.一致性哈希增删节点时，会导致部分数据无法命中，并且导致下一个节点的压力增大，造成缓存雪崩</p>
    <p>2.哈希槽的数据分布比一致性哈希更加均匀</p>
    <p>3.哈希槽增删节点更加便捷，只需要将原有的数据移动到其他节点即可</p>
</details>

## 29.为什么Redis的哈希槽是16384个？
<details>
    <summary>答案</summary>
    <p>因为如何有更多的槽位会导致心跳包更大，浪费带宽。主节点的配置信息的哈希槽是通过bitmap记录的，如果哈希槽越少，压缩率更高</p>
</details>

## 30.Redis常见数据结构的实现
<details>
    <summary>答案</summary>
    <p>1.String redis的字符串是通过int和sds实现的，sds不仅可以保存文本数据，还可以保存二进制数据。并且获取字符串长度的复杂度是O（1），因为sds存储了字符串的长度，并且sds是安全的，拼接字符串不会造成缓冲区溢出</p>
    <p>2.List 因为压缩列表是连续存储的，发生修改时，导致联动更新，而双向链表的空间开销太大。所以将二者相结合 redis的list通过quicklist实现，quick本质上是个双向链表，里面存储的是压缩列表，结合了压缩列表和双向链表的优点，有效节省存储空间的同时有较高的效率。</p>
    <p>3.hash redis的hash在元素个数少于512并且所有值小于64字节时，基于listpack实现，listpack沿用了ziplist的紧凑布局，通过不存在上一个元素的长度避免了连锁更新的问题，通过encoding记录了元素的数据类型和长度，通过element-tot-len记录encoding和data的长度，从而支持方向遍历，否则会采用哈希表，哈希表底层存储了两个字典，一个用于扩容,会在必要的时候进行扩容和缩容，rehash</p>
    <p>4.set redis的set，在元素类型都是int并且元素个数不超过512的时候，会采用整数集合，整数集合的底层是一个有序数组。否则采用哈希表</p>
    <p>5.zset zset在元素个数小于128并且每个元素的值都小于64字节时，采用listpack，否则采用跳表。跳表是一个有序数据结构，它通过在每个节点维护多个指向其他节点指针，从而达到快速访问节点的目的</p>
</details>

## 31.Redis初始化会做些什么工作？
<details>
    <summary>答案</summary>
    <p>Redis 初始化的时候，会做下面这几件事情</p>
    <p>首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket</p>
    <p>然后，调用 bind() 绑定端口和调用 listen() 监听该 socket</p>
    <p>将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数</p>
</details>

## 31.Redis初始化会做些什么工作？
<details>
    <summary>答案</summary>
    <p>Redis 初始化的时候，会做下面这几件事情</p>
    <p>首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket</p>
    <p>然后，调用 bind() 绑定端口和调用 listen() 监听该 socket</p>
    <p>将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数</p>
</details>

## 32.什么是IO多路复用？
<details>
    <summary>答案</summary>
    <p>Redis 采用了 I/O 多路复用机制处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>
</details>

## 33.Redis 采用单线程为什么还这么快？
<details>
    <summary>答案</summary>
    <p>Redis的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了。</p>
    <p>Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</p>
    <p>Redis 采用了 I/O 多路复用机制处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>
</details>

## 34.Redis分布式锁，过期时间不够怎么办?
<details>
<summary>答案</summary>
<p>可以使用看门狗机制，监控锁的过期时间，定期给锁续期</p>
</details>

