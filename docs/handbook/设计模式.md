# 设计模式

## 1.创建型模式

### 1.1 工厂模式

工厂模式包含一个工厂接口，不同的工厂子类会实现工厂接口，从而生产不同的产品子类，这些产品子类都实现了产品接口

优点：
1.客户端只需要关系创建对应产品的工厂即可，无需关心创建细节
2.符合开闭原则，添加新的产品，只需要添加新的产品子类和工厂子类即可

缺点：
1.会导致出现非常多的子类，代码变的非常复杂

### 1.2 抽象工厂模式

抽象工厂模式包括一个工厂接口，不同的工厂子类会实现抽象工厂接口，抽象工厂接口提供了生成不同类型的产品的方法，不同的工厂子类实现抽象工厂接口，从而生产不同的产品子类。这些产品子类都实现了抽象产品接口

抽象工厂模式和工厂模式的区别就是抽象工厂对产品进行了一层抽象

优点：
1.客户端只需要关系创建对应产品的工厂即可，无需关心创建细节
2.符合开闭原则，添加新的产品，只需要添加新的产品子类和工厂子类即可

缺点：
1.在添加产品类型时，所有的工厂子类都需要修改

### 1.3 生成器模式

生成器模式就是一个主管类来负责控制产品的生成步骤，从而更好的复用特定的产品。然后有一个生成器接口，由生成器子类实现这些接口，主管类操作生成器来生成不同的产品

优点：
1.生成不同形式的产品时，可以复用相同的制造代码
2.符合单一职责原则，可以将复杂的构造代码从产品的业务逻辑中分离出来

缺点：
1.整体复杂程度会增加很多

### 1.4 原型模式

原型模式包含一个原型接口，有一个克隆自身的方法，然后由原型子类实现该接口。从而使得客户端可以通过接口直接克隆对象

优点：
1.可以更方便的生成复杂的对象
2.可以克隆对象无需与它们所属的具体类耦合

缺点：
1.克隆包含循环引用的复杂对象可能非常麻烦

### 1.5 单例模式

单例模式通过声明一个私有静态成员实例，然后对外提供一个获取实例的方法来保证实例只被生成一次

优点：
1.保证一个类只有一个实例
2.仅在首次请求的时候对实例进行初始化
3.获得了一个全局访问实例的节点

缺点：
1.违反了单一职责原则，单例模式同时解决了两个问题，保证只有一个实例，提供全局访问实例的节点
2.在多线程环境下需要特殊处理
3.不适用于变化的对象，在某些场景下需要对单例进行修改，会影响其他场景的数据
4.单例模式没有抽象层，因此很难进行扩展

## 2.结构性模式

### 2.1 适配器模式

适配器模式有一个客户端接口，由适配器类实现客户端接口，然后将客户端的数据与服务累需要的数据进行适配

优点：
1.符合单一职责原则，将数据转换的逻辑从业务逻辑中抽离出来
2.符合开闭原则，客户端只需要与客户端接口交互，可以不修改客户端代码，添加新类型的适配器

缺点：
1.代码整体复杂度增加，有时候改动服务类使其和其他代码兼容会更简单