# 操作系统八股

1.CPU中的Cache如何将数据写回内存

<details>
    <summary>答案</summary>
    <p>
        有两种方式，写直达和写回
        写直达，首先判断该数据是否存在Cache中，如果存在，则写入Cache，再写入内存。否则直接写入内存
        写回，首先判断该数据是否存在Cache中，如果存在，则直接写入Cache，将其标记为脏，如果不存在，定位到对应的Cache块，如果该块为脏，则先将其写入内存，然后再将要写入的数据从内存读出，再写入到Cache，标记为脏。如果该块不为脏，则将要写入的数据从内存读出，然后将要写入的数据写入Cache
    </p>
</details>
2.多核CPU如何保证缓存一致性

<details>
    <summary>答案</summary>
    <p>
        通过基于总线嗅探机制的MESI协议，维护了已修改，独占，共享，已失效四个状态。根据来自本地核心的请求，或者是来自其他CPU核心通过总线传输过来的请求，从而构成一个流动的状态机，对于处于已修改或独占状态的CacheLine，修改数据时，不需要发送广播给其他CPU核心
        总线嗅探协议无法保证事务的串行化，而MESI协议很好的解决了这个问题
    </p>
</details>

3.什么是中断？

<details>
    <summary>答案</summary>
    <p>
        中断是操作系统用来打断当前执行的进程，转而执行中断处理程序的一种机制
        分为硬中断和软中断，硬中断是由硬件触发中断，用于快速处理中断，软中断，由内核触发中断，用来异步的完成硬中断没完成的工作
    </p>
</details>

4.为什么要有虚拟内存

<details>
    <summary>答案</summary>
    <p>
        1.虚拟内存使得进程的运行内存可以超过物理内存的大小，因为程序符合局部性原理，CPU访问内存会有很明显的重复访问的倾向性，对于那些没有经常访问的数据，我们可以将其换出物理内存
        2.虚拟内存使得每个进程都有自己的页表，每个进程的虚拟内存空间都是独立的，解决了多进程地址空间冲突的问题
        3.虚拟内存的页表中记录了一个页的读写权限，再内存访问方面，为操作系统提供了更好的安全性
    </p>
</details>

5.内存分段机制

<details>
    <summary>答案</summary>
    <p>
         内存分段机制将一个程序分成多个逻辑段，如代码段，栈段，堆段，数据段，每个段有自己的属性，分段机制下，虚拟地址由段选择因子和段内偏移组成。段选择因子包括段号，段的界限，段的特权等级。
    </p>
</details>

6.内存分页机制

<details>
    <summary>答案</summary>
    <p>
        将整个虚拟内存和物理内存都分成固定大小的页，页与页之间是紧密排列的，不会有外部碎片。分页机制下，虚拟地址由页号和页内偏移量组成，然后通过页表，将虚拟地址中的页号映射到物理页号。
    </p>
</details>

7.内存分段和分页机制的缺点

<details>
    <summary>答案</summary>
    <p>
        分段机制的缺点是容易产生外部碎片，内存交换效率低，因为容易产生外部碎片，所以经常需要将数据交换到磁盘，但是磁盘访问速度太慢，所以会导致内存交换效率很低
        分页机制的缺点是容易产生内部碎片，因为分页机制的最小单位是页，所以即使程序不足一页，也只能分配一页
    </p>
</details>

8.分页机制如何解决外部碎片和内存交换效率低的问题？

<details>
    <summary>答案</summary>
    <p>
        因为分页机制的页与页之间都是紧密排列的，所以不会有外部碎片，当内存空间不足时，会将少数的一个或几个页换出到磁盘上，不会花太多时间，因此内存交换效率比较高
    </p>
</details>
9.段页式机制

<details>
    <summary>答案</summary>
    <p>
        先将程序划分成多个有逻辑意义的段，再将每个段分成多个页。每个程序一个段表，每个段由有一张页表，在段页式机制下，虚拟地址由段号，段内页号，页内偏移组成。
    </p>
</details>
10.malloc通过brk()和mmap()申请内存的区别

<details>
    <summary>答案</summary>
    <p>
        1.通过brk()方式申请内存时，free释放内存时，并不会把内存归还给操作系统，而是在malloc的内存池中，待下次使用
        2.通过mmap()方式申请内存时，free释放内存时，会把内存归还给操作系统，内存得到真正的释放
    </p>
</details>

11.为什么不全部使用 mmap 来分配内存？

<details>
    <summary>答案</summary>
    <p>
        因为使用mmap分配内存会导致每次都发生运行态的切换，还会导致缺页中断，会导致CPU消耗太大
    </p>
</details>

12.为什么不全部使用 brk来分配内存?

<details>
    <summary>答案</summary>
    <p>
        brk分配内存很容易造成内存碎片，对于小块内存，堆内会产生越来越多的不可用的碎片，从而造成内存泄漏
    </p>
</details>

13.malloc返回的地址结构

<details>
    <summary>答案</summary>
    <p>
        包括内存的头信息和用户使用的内存块
    </p>
</details>

14.内存回收机制

<details>
    <summary>答案</summary>
    <p>
        当内存分配时，可分配内存不够就会触发后台内存回收，这个回收过程是异步的，然后检查是否有足够的空闲物理内存，如果还不够，则启用直接内存回收，这是同步的过程。如果还不够，则会触发OOM机制。内存回收的时候，对于文件页，如果是脏页，先写入磁盘，再回收，否则，直接回收，对于匿名页，先写入磁盘，再回收。在回收时，会从通过LRU算法，取出队尾的内存页，因为他是很少被访问的，将其回收
    </p>
</details>
15.回收内存带来的影响


<details>
    <summary>答案</summary>
    <p>
        1.对于后台内存回收，是异步回收的，因此不会阻塞进程
        2.对于直接内存回收，是同步回收的，会阻塞进程，这会造成很长时间的延迟，以及系统的CPU利用率会身高，导致系统负载升高
    </p>
</details>
16.在4g的机器上申请8g的内存会怎么样?

<details>
    <summary>答案</summary>
    <p>
        首先要考虑是32位还是64位的操作系统，32位可申请的内存是3G，64位可申请俄内出是128T。
        如果超过对应的，将会申请失败。然后考虑是否访问内存，如果不访问，因为保存虚拟内存的数据结构需要内存，所以只要物理内存充足，就可以申请成功。如果物理内存不足，开启swap机制也可以申请成功。如果访问，超过物理内存后，不开启swap机制将会触发OOM。
    </p>
</details>

17.swap机制

<details>
    <summary>答案</summary>
    <p>
        当系统内存不足或大量内存闲置时，swap机制会将进程暂时不用的内存数据存储到磁盘中，并释放这些数据的内存。当进程再次访问这些内存时，再把它们从磁盘读到内存中来
    </p>
</details>

18.linux如何避免预读失效(预读到一些没有用的)和缓存污染(读入大量数据导致热点数据被删除)

<details>
    <summary>答案</summary>
    <p>
        linux是基于LRU算法，将其划分成活跃链表和非活跃链表，预读的页加入到非活跃链表的头部，当页被真正访问时，才将页插入活跃链表头部，如果预读的页没有被访问，也不会影响活跃链表中的热点数据
        缓存污染是因为大量数据直接进入活跃链表，所以我们要提高进入活跃链表的门槛，因为大量的数据只会被读入一次，因为不会被加入到活跃链表，而造成热点数据被替换掉
    </p>
</details>

19.进程虚拟空间的组成

<details>
    <summary>答案</summary>
    <p>
        由栈，文件映射和匿名映射区，堆，BSS段，数据段，代码段组成。BSS段是未初始化的数据，文件映射和匿名映射区就是通过mmap申请的内存
    </p>
</details>

20.用户空间和内核空间

<details>
    <summary>答案</summary>
    <p>
        用户空间是应用程序的运行空间。内核空间是内核的运行空间，
        进程在用户态时，只能访问用户空间。只有进入内核态，才能访问内核空间
    </p>
</details>

21.进程上下文切换的过程

<details>
    <summary>答案</summary>
    <p>
       首先会从用户态切换到内核态，然后保存进程上下文，然后加载另一个进程的进程上下文。
    </p>
</details>

22.CPU上下文切换

<details>
    <summary>答案</summary>
    <p>
        先将CPU上下文(CPU寄存器和程序计数器)保存起来，然后加载新任务的上下文到寄存器和程序计数器中，最后再跳转到程序计数器所指的新位置
    </p>
</details>

23.进程上下文是什么?

<details>
    <summary>答案</summary>
    <p>
        进程上下文包括寄存器，程序计数器，栈指针，PCB，核心栈，页表等信息
    </p>
</details>

24.什么是进程？什么是线程？什么是协程？

<details>
    <summary>答案</summary>
    <p>
        进程是执行中的程序。线程是进程的一个执行流程。协程是一种用户态的，不被操作系统所管理的，完全由用户控制的，比线程更加轻量级的存在
    </p>
</details>

25.进程和线程的区别？

<details>
    <summary>答案</summary>
    <p>
        1.进程是资源分配的单位，线程是CPU调度的单位
        2.进程拥有完整的资源，而线程只独享必不可少的资源，如寄存器和栈
        3.进程上下文切换需要保存更多的上下文信息，而因为同一进程的线程共享了进程的信息，故需要保存的上下文更少
        4.多进程可以充分利用多核CPU进行并发处理，而多线程依赖于单个CPU的多个执行单元进行并发执行
        5.线程之间的访问需要进行协同和同步，否则会出现竞争条件和死锁。
    </p>
</details>

26.线程上下文切换

<details>
    <summary>答案</summary>
    <P>
        如果两个线程属于同一个进程，则只需要切换线程的私有数据和寄存器等数据
        如果两个线程不属于同一个进程，则和进程上下文切换一样。
    </P>
</details>

27.线程和协程的区别

<details>
    <summary>答案</summary>
    <p>
        1.线程的调度由操作系统控制，而协程的调度由用户自己控制
        2.线程的切换需要由用户态切换到内核态，而协程的切换不需要
        3.同一时间，多核处理器的环境下，多线程可以是并行的，但是多协程是并发的
        4.线程通常是抢占式的，而协程是协同式的。
    </p>
</details>

28.进程调度算法

<details>
    <summary>答案</summary>
    <p>
        进程调度算法包括先来先服务，最短作业优先，高响应比优先，时间片轮转，多级反馈队列，最高优先级
        先来先服务对长作业有利，适合CPU密集型，不适合IO密集型的系统
        最短作业优先，对长作业不利，可能导致长作业一直不能运行
        高响应比优先权衡了短作业和长作业
        最高优先级，可能会导致低优先级的作业永远无法运行
        多级反馈队列，兼顾了长短作业，同时有较好的响应时间
    </p>
</details>

29.页面置换算法

<details>
    <summary>答案</summary>
    <p>
    最佳页面置换算法(太过理想没法实现，将未来最长时间不访问的页面置换)，最近最久未使用置换算法(LRU)，先进先出置换算法(FIFO)，时钟页面替换算法(维护一个环形链表，每个页面记录一个访问标志位，置换时，遇到访问标志位为1的就将其改成0，遇到0就将其置换，当页面被访问时，将标志位设为1，最不常用算法(LFU)
    </p>
</details>

30.磁盘调度算法

<details>
    <summary>答案</summary>
    <p>
        先来先服务,最短寻道时间优先，扫描算法(选定某一个方向，直到最后一个磁道，才调转方向，返回途中处理请求)，循环扫描算法（选定某一个方向，直到最后一个磁道，才调转方向，返回途中不处理请求），LOOK算法（基于扫描算法的改进，磁头只会移动到最远的请求位置，然后立即反向移动，返回途中处理请求），C-LOOK算法（基于循环扫描算法的改进，磁头只会移动到最远的请求位置，然后立即反向移动，返回途中不处理请求）
    </p>
</details>
31.虚拟内存和物理内存

<details>
    <summary>答案</summary>
    <p>
		虚拟内存是一种内存管理技术，将程序使用的内存地址（虚拟地址）映射到物理内存的地址。        
    </p>
</details>

32.select,poll,epoll

<details>
    <summary>答案</summary>
    <p>
        select就是将已连接的socket列表拷贝到内核中，然后由内核检查是否有网络事件产生，通过遍历socket列表，然后将有网络事件产生的socket标记为可读或可写，然后再拷贝到用户态，用户态再遍历socket列表，找到可读或可写的socket,对其进行处理
        poll就是将select使用的bitsmap替换成了链表，从而不会受到bitsmap长度的限制
        epoll在内核中使用红黑树来关注进程所有待检测的socket,从而减少数据拷贝，使用事件驱动机制，内核里维护了一个链表来记录就绪事件，只将有事件发生的socket列表传递给应用程序，不需要扫描整个集合
    </p>
</details>

33.用户态和内核态

<details>
    <summary>答案</summary>
    <p>
        用户态是应用程序运行的状态，处于用户态时只能访问受限的内存，而处于内核态时，可以访问任何数据
    </p>
</details>

34.操作系统进行内存管理的意义？

<details>
    <summary>答案</summary>
    <p>
		1.优化内存使用效率
        2.保证进程之间使用内存互不干扰，保证系统的安全性
        3.更加高效的申请和释放内存
    </p>
</details>



