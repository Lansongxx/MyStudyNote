{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{423:function(e,t,r){\"use strict\";r.r(t);var n=r(23),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"p\",[e._v(\"二十三个经典的 \"),r(\"a\",{attrs:{href:\"https://pattern.windliang.wang/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"设计模式\"),r(\"OutboundLink\")],1),e._v(\" 已经过完了 ，这里再把一些基本原则过一下，以便平时开发中可以更好的体会。\")]),e._v(\" \"),r(\"h1\",{attrs:{id:\"单一职责原则-srp-single-responsibility-principle\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#单一职责原则-srp-single-responsibility-principle\"}},[e._v(\"#\")]),e._v(\" 单一职责原则 SRP(Single Responsibility Principle)\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v('There should never be more than one reason for a class to change.\" In other words, every class should have only one responsibility.')])]),e._v(\" \"),r(\"p\",[e._v(\"定义：一个类或者模块应该有且只有一个改变的原因，在 \"),r(\"code\",[e._v(\"js\")]),e._v(\" 中的话更多的会应用在对象、函数中。\")]),e._v(\" \"),r(\"p\",[e._v(\"最难的地方就在于结合具体场景对单一职责的判定了，为了应用这个原则把一个模块拆的太细其实也不太好，所以需要我们在方便性和稳定性之间做一个权衡。\")]),e._v(\" \"),r(\"p\",[e._v(\"之前讲的 \"),r(\"a\",{attrs:{href:\"https://pattern.windliang.wang/posts/%E5%89%8D%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"代理模式\"),r(\"OutboundLink\")],1),e._v(\"、\"),r(\"a\",{attrs:{href:\"https://pattern.windliang.wang/posts/%E5%89%8D%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"装饰器模式\"),r(\"OutboundLink\")],1),e._v(\" 都有体现。\")]),e._v(\" \"),r(\"h1\",{attrs:{id:\"开闭原则-ocp-open-closed-principle\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#开闭原则-ocp-open-closed-principle\"}},[e._v(\"#\")]),e._v(\" 开闭原则 OCP(open–closed principle)\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"Software entities should be open for extension, but closed for modification.\")])]),e._v(\" \"),r(\"p\",[e._v(\"定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。模块应尽量在不修改原代码的情况下进行扩展。\")]),e._v(\" \"),r(\"p\",[e._v(\"平常开发中，要把变的部分和不变的部分分离出来，设计一个结构的时候尽可能的考虑一下未来可能变化的部分。\")]),e._v(\" \"),r(\"p\",[e._v(\"可以通过放置 \"),r(\"code\",[e._v(\"hook\")]),e._v(\" 、使用回调函数的方式达到扩展的目的。\")]),e._v(\" \"),r(\"p\",[e._v(\"之前讲的 \"),r(\"a\",{attrs:{href:\"https://pattern.windliang.wang/posts/%E5%89%8D%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"发布订阅模式\"),r(\"OutboundLink\")],1),e._v(\"、\"),r(\"a\",{attrs:{href:\"https://pattern.windliang.wang/posts/%E5%89%8D%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97-%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"模版方法模式\"),r(\"OutboundLink\")],1),e._v(\"、\"),r(\"a\",{attrs:{href:\"https://pattern.windliang.wang/posts/%E5%89%8D%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"策略模式\"),r(\"OutboundLink\")],1),e._v(\"、\"),r(\"a\",{attrs:{href:\"https://pattern.windliang.wang/posts/%E5%89%8D%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"职责链模式\"),r(\"OutboundLink\")],1),e._v(\" 都有体现。\")]),e._v(\" \"),r(\"h1\",{attrs:{id:\"里氏替换原则-lsp-liskov-substitution-principle\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#里氏替换原则-lsp-liskov-substitution-principle\"}},[e._v(\"#\")]),e._v(\" 里氏替换原则 LSP(Liskov substitution principle)\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\")])]),e._v(\" \"),r(\"p\",[e._v(\"定义：所有引用基类的地方必须能透明地使用其子类的对象，也可以简单理解为任何基类可以出现的地方，子类一定可以出现。\")]),e._v(\" \"),r(\"p\",[e._v(\"举个例子就是如果某个地方可以用 \"),r(\"code\",[e._v(\"A\")]),e._v(\" 类， \"),r(\"code\",[e._v(\"B\")]),e._v(\" 类继承于 \"),r(\"code\",[e._v(\"A\")]),e._v(\" 类，那么这个地方一定可以使用 \"),r(\"code\",[e._v(\"B\")]),e._v(\" 类。\")]),e._v(\" \"),r(\"p\",[e._v(\"这个原则告诉我们在继承类的时候，如果要实现一个新功能，不要去覆盖父类已经实现的方法，而应该去写一个新方法。\")]),e._v(\" \"),r(\"p\",[e._v(\"平常前端开发中很少去写类和继承，这个原则用的比较少。\")]),e._v(\" \"),r(\"h1\",{attrs:{id:\"接口隔离原则-isp-interface-segregation-principle\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#接口隔离原则-isp-interface-segregation-principle\"}},[e._v(\"#\")]),e._v(\" 接口隔离原则 ISP(Interface Segregation Principle)\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"Many client-specific interfaces are better than one general-purpose interface.\")])]),e._v(\" \"),r(\"p\",[e._v(\"定义：客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。简单来说就是建立单一的接口，不要建立臃肿庞大的接口。也就是接口尽量细化，同时接口中的方法尽量少。\")]),e._v(\" \"),r(\"p\",[e._v(\"举个例子就是 \"),r(\"code\",[e._v(\"A\")]),e._v(\" 接口有 \"),r(\"code\",[e._v(\"5\")]),e._v(\" 个方法，\"),r(\"code\",[e._v(\"B\")]),e._v(\" 类实现 \"),r(\"code\",[e._v(\"A\")]),e._v(\" 接口，但 \"),r(\"code\",[e._v(\"B\")]),e._v(\" 类只用到其中的 \"),r(\"code\",[e._v(\"3\")]),e._v(\" 个方法，此时可以考虑对 \"),r(\"code\",[e._v(\"A\")]),e._v(\" 接口进行拆分。\")]),e._v(\" \"),r(\"p\",[r(\"code\",[e._v(\"js\")]),e._v(\" 中没有接口，忽略。\")]),e._v(\" \"),r(\"h1\",{attrs:{id:\"依赖倒转原则-dip-dependency-inversion-principle\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#依赖倒转原则-dip-dependency-inversion-principle\"}},[e._v(\"#\")]),e._v(\" 依赖倒转原则 DIP(Dependency Inversion Principle)\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"Depend upon abstractions, not concretions\")])]),e._v(\" \"),r(\"p\",[e._v(\"定义： 程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\")]),e._v(\" \"),r(\"p\",[e._v(\"其实就是经常说的面向接口（或者基类）编程。\")]),e._v(\" \"),r(\"p\",[e._v(\"但 \"),r(\"code\",[e._v(\"js\")]),e._v(\" 中没有接口和抽象类，这种原则也就用不到了。\")]),e._v(\" \"),r(\"p\",[e._v(\"上边五个原则就是经常看到的 \"),r(\"code\",[e._v(\"SOLID\")]),e._v(\" 原则，除了这些还有几个其他的原则。\")]),e._v(\" \"),r(\"h1\",{attrs:{id:\"最小知道原则-lod-principle-of-least-knowledge\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#最小知道原则-lod-principle-of-least-knowledge\"}},[e._v(\"#\")]),e._v(\" 最小知道原则 LOD(principle of least knowledge)\")]),e._v(\" \"),r(\"p\",[e._v(\"定义：一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。\")]),e._v(\" \"),r(\"p\",[e._v(\"实体的话在前端中更多的对应对象、函数，\"),r(\"a\",{attrs:{href:\"https://pattern.windliang.wang/posts/%E5%89%8D%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"门面模式\"),r(\"OutboundLink\")],1),e._v(\" 可以看作该原则的应用。\")]),e._v(\" \"),r(\"p\",[e._v(\"最小知道原则又叫做迪米特法则 LOD(Law of Demeter)，迪米特其实是宙斯(Zeus) 的姐姐，名字来源的话这里截取下\"),r(\"a\",{attrs:{href:\"https://en.wikipedia.org/wiki/Law_of_Demeter\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"维基百科\"),r(\"OutboundLink\")],1),e._v(\"。\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[r(\"em\",[e._v(\"The Greek goddess of Agriculture.\")])]),e._v(\" \"),r(\"p\",[e._v(\"The Demeter project was named after Demeter because we were working on a hardware description language Zeus and we were looking for a tool to simplify the implementation of Zeus. We were looking for a tool name related to Zeus and we chose a sister of Zeus: Demeter.\")]),e._v(\" \"),r(\"p\",[e._v(\"Later we promoted the idea that Demeter-style software development is about growing software as opposed to building software. We introduced the concept of a growth plan which is basically a sequence of more and more complex UML class diagrams.\")]),e._v(\" \"),r(\"p\",[e._v(\"Growth plans are useful for building systems incrementally.\")])]),e._v(\" \"),r(\"p\",[e._v(\"大意就是当时是用一个叫做 \"),r(\"code\",[e._v(\"Zeus\")]),e._v(\" 的硬件语言，然后找到了一个优化 \"),r(\"code\",[e._v(\"Zens\")]),e._v(\" 的工具，为了让它们产生联系，就起了 \"),r(\"code\",[e._v(\"Demeter\")]),e._v(\" 这个名字。\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://windliangblog.oss-cn-beijing.aliyuncs.com/windliangblog.oss-cn-beijing.aliyuncs.com25_29914_743225_ccd123bf574133ea11e60e85e7057014_38a998_301.jpg\",alt:\"img\"}})]),e._v(\" \"),r(\"p\",[e._v(\"另外截取一下 「JavaScript 设计开发与实现」书里提到的关于两个名字之间的建议：\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"许多人更倾向于使用迪米特法则这个名字，也许是因为显得更酷一点。但本书参考 \"),r(\"em\",[e._v(\"Head First\")])]),e._v(\" \"),r(\"p\",[r(\"em\",[e._v(\"Design Patterns\")]),e._v(\" 的建议，称之为最少知识原则。一是因为这个名字更能体现其含义，另一个原因\")]),e._v(\" \"),r(\"p\",[e._v(\"是“法则”给人的感觉是必须强制遵守，而原则只是一种指导，没有哪条原则是在实际开发中必\")]),e._v(\" \"),r(\"p\",[e._v(\"须遵守的。比如，虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难\")]),e._v(\" \"),r(\"p\",[e._v(\"以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则，\")]),e._v(\" \"),r(\"p\",[e._v(\"要根据具体的环境来定。\")])]),e._v(\" \"),r(\"h1\",{attrs:{id:\"合成-聚合复用原则-carp-composite-aggregate-reuse-principle\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#合成-聚合复用原则-carp-composite-aggregate-reuse-principle\"}},[e._v(\"#\")]),e._v(\" 合成/聚合复用原则 CARP(Composite/Aggregate Reuse Principle)\")]),e._v(\" \"),r(\"p\",[e._v(\"定义：尽量使用合成/聚合，而不是通过继承达到复用的目的。\")]),e._v(\" \"),r(\"h1\",{attrs:{id:\"kiss-原则\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#kiss-原则\"}},[e._v(\"#\")]),e._v(\" KISS 原则\")]),e._v(\" \"),r(\"p\",[e._v(\"定义： Keep It Simple, Stupid，在设计中应当注重简约的原则。\")]),e._v(\" \"),r(\"h1\",{attrs:{id:\"yagni-原则\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#yagni-原则\"}},[e._v(\"#\")]),e._v(\" YAGNI 原则\")]),e._v(\" \"),r(\"p\",[e._v(\"定义：You aren't gonna need it，表示暂时不需要的就不要做。\")]),e._v(\" \"),r(\"h1\",{attrs:{id:\"dry-原则\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dry-原则\"}},[e._v(\"#\")]),e._v(\" DRY 原则\")]),e._v(\" \"),r(\"p\",[e._v(\"定义：Don't Repeat Yourself，不要写重复的代码。\")]),e._v(\" \"),r(\"h1\",{attrs:{id:\"总\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总\"}},[e._v(\"#\")]),e._v(\" 总\")]),e._v(\" \"),r(\"p\",[e._v(\"所有的原则只是协助于我们写成易维护、易扩展的代码，不能为了去实现而实现、进行过度设计。\")]),e._v(\" \"),r(\"p\",[e._v(\"一些代码如果未来完全不用改变，那就用最简单的方式实现即可，当第二次、第三次修改的时候再来重构也不迟。\")]),e._v(\" \"),r(\"p\",[e._v(\"设计模式和基本原则的应用一定是结合具体场景的，空谈的话也没有任何意义。\")]),e._v(\" \"),r(\"p\",[e._v(\"我们只需要先了解这些原则，然后在日常开发中慢慢进行体会。\")])])}),[],!1,null,null,null);t.default=a.exports}}]);","extractedComments":[]}