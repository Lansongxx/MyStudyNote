(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{421:function(v,_,n){"use strict";n.r(_);var a=n(23),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,n=v._self._c||_;return n("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[n("h1",{attrs:{id:"操作系统"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#操作系统"}},[v._v("#")]),v._v(" 操作系统")]),v._v(" "),n("p",[v._v("1.CPU中的Cache如何将数据写回内存\n")]),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("有两种方式，写直达和写回")]),v._v(" "),n("p",[v._v("写直达：首先判断该数据是否存在Cache中，如果存在，则写入Cache，再写入内存。否则直接写入内存")]),v._v(" "),n("p",[v._v("写回：首先判断该数据是否存在Cache中，如果存在，则直接写入Cache，将其标记为脏。如果不存在，定位到对应的Cache块，如果该块为脏，则先将其写入内存，然后再将要写入的数据从内存读出(为了获取到cache对应内存中的位置，使得下次查找时，可以直接找到内存中的数据)，再写入到Cache，标记为脏。如果该块不为脏，则将要写入的数据从内存读出，然后将要写入的数据写入Cache")])]),v._v(" "),n("p",[v._v("\n2.多核CPU如何保证缓存一致性\n")]),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("通过基于总线嗅探机制的MESI协议，维护了已修改，独占，共享，已失效四个状态。根据来自本地核心的请求，或者是来自其他CPU核心通过总线传输过来的请求，从而构成一个流动的状态机，对于处于已修改或独占状态的CacheLine，修改数据时，不需要发送广播给其他CPU核心")]),v._v(" "),n("p",[v._v("总线嗅探协议无法保证事务的串行化，而MESI协议很好的解决了这个问题")])]),n("p"),v._v(" "),n("p",[v._v("\n3.什么是中断？\n")]),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("中断是操作系统用来打断当前执行的进程，转而执行中断处理程序的一种机制")]),v._v(" "),n("p",[v._v("分为硬中断和软中断，硬中断是由硬件触发中断，用于快速处理中断。软中断，由内核触发中断，用来异步的完成硬中断没完成的工作")])]),v._v(" "),n("p",[v._v("4.为什么要有虚拟内存")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("1.虚拟内存使得进程的运行内存可以超过物理内存的大小，因为程序符合局部性原理，CPU访问内存会有很明显的重复访问的倾向性，对于那些没有经常访问的数据，我们可以将其换出物理内存")]),v._v(" "),n("p",[v._v("2.虚拟内存使得每个进程都有自己的页表，每个进程的虚拟内存空间都是独立的，解决了多进程地址空间冲突的问题")]),v._v(" "),n("p",[v._v("3.虚拟内存的页表中记录了一个页的读写权限，在内存访问方面，为操作系统提供了更好的安全性")])]),v._v(" "),n("p",[v._v("5.内存分段机制")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n         内存分段机制将一个程序分成多个逻辑段，如代码段，栈段，堆段，数据段，每个段有自己的属性，分段机制下，虚拟地址由段选择因子和段内偏移组成。段选择因子包括段号，段的界限，段的特权等级。\n    ")])]),v._v(" "),n("p",[v._v("6.内存分页机制")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        将整个虚拟内存和物理内存都分成固定大小的页，页与页之间是紧密排列的，不会有外部碎片。分页机制下，虚拟地址由页号和页内偏移量组成，然后通过页表，将虚拟地址中的页号映射到物理页号。\n    ")])]),v._v(" "),n("p",[v._v("7.内存分段和分页机制的缺点")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        分段机制的缺点是容易产生外部碎片，内存交换效率低，因为容易产生外部碎片，所以经常需要将数据交换到磁盘，但是磁盘访问速度太慢，所以会导致内存交换效率很低\n        分页机制的缺点是容易产生内部碎片，因为分页机制的最小单位是页，所以即使程序不足一页，也只能分配一页\n    ")])]),v._v(" "),n("p",[v._v("8.分页机制如何解决外部碎片和内存交换效率低的问题？")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        因为分页机制的页与页之间都是紧密排列的，所以不会有外部碎片，当内存空间不足时，会将少数的一个或几个页换出到磁盘上，不会花太多时间，因此内存交换效率比较高\n    ")])]),v._v("\n9.段页式机制\n"),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        先将程序划分成多个有逻辑意义的段，再将每个段分成多个页。每个程序一个段表，每个段由有一张页表，在段页式机制下，虚拟地址由段号，段内页号，页内偏移组成。\n    ")])]),v._v("\n10.malloc通过brk()和mmap()申请内存的区别\n"),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        1.通过brk()方式申请内存时，free释放内存时，并不会把内存归还给操作系统，而是在malloc的内存池中，待下次使用\n        2.通过mmap()方式申请内存时，free释放内存时，会把内存归还给操作系统，内存得到真正的释放\n    ")])]),v._v(" "),n("p",[v._v("11.为什么不全部使用 mmap 来分配内存？")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        因为使用mmap分配内存会导致每次都发生运行态的切换，还会导致缺页中断，会导致CPU消耗太大\n    ")])]),v._v(" "),n("p",[v._v("12.为什么不全部使用 brk来分配内存?")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        brk分配内存很容易造成内存碎片，对于小块内存，堆内会产生越来越多的不可用的碎片，从而造成内存泄漏\n    ")])]),v._v(" "),n("p",[v._v("13.malloc返回的地址结构")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        包括内存的头信息和用户使用的内存块\n    ")])]),v._v(" "),n("p",[v._v("14.内存回收机制")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        当内存分配时，可分配内存不够就会触发后台内存回收，这个回收过程是异步的，然后检查是否有足够的空闲物理内存，如果还不够，则启用直接内存回收，这是同步的过程。如果还不够，则会触发OOM机制。内存回收的时候，对于文件页，如果是脏页，先写入磁盘，再回收，否则，直接回收，对于匿名页，先写入磁盘，再回收。在回收时，会从通过LRU算法，取出队尾的内存页，因为他是很少被访问的，将其回收\n    ")])]),v._v("\n15.回收内存带来的影响\n"),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        1.对于后台内存回收，是异步回收的，因此不会阻塞进程\n        2.对于直接内存回收，是同步回收的，会阻塞进程，这会造成很长时间的延迟，以及系统的CPU利用率会身高，导致系统负载升高\n    ")])]),v._v("\n16.在4g的机器上申请8g的内存会怎么样?\n"),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        首先要考虑是32位还是64位的操作系统，32位可申请的内存是3G，64位可申请俄内出是128T。\n        如果超过对应的，将会申请失败。然后考虑是否访问内存，如果不访问，因为保存虚拟内存的数据结构需要内存，所以只要物理内存充足，就可以申请成功。如果物理内存不足，开启swap机制也可以申请成功。如果访问，超过物理内存后，不开启swap机制将会触发OOM。\n    ")])]),v._v(" "),n("p",[v._v("17.swap机制")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        当系统内存不足或大量内存闲置时，swap机制会将进程暂时不用的内存数据存储到磁盘中，并释放这些数据的内存。当进程再次访问这些内存时，再把它们从磁盘读到内存中来\n    ")])]),v._v(" "),n("p",[v._v("18.linux如何避免预读失效(预读到一些没有用的)和缓存污染(读入大量数据导致热点数据被删除)")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        linux是基于LRU算法，将其划分成活跃链表和非活跃链表，预读的页加入到非活跃链表的头部，当页被真正访问时，才将页插入活跃链表头部，如果预读的页没有被访问，也不会影响活跃链表中的热点数据\n        缓存污染是因为大量数据直接进入活跃链表，所以我们要提高进入活跃链表的门槛，因为大量的数据只会被读入一次，因为不会被加入到活跃链表，而造成热点数据被替换掉\n    ")])]),v._v(" "),n("p",[v._v("19.进程虚拟空间的组成")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        由栈，文件映射和匿名映射区，堆，BSS段，数据段，代码段组成。BSS段是未初始化的数据，文件映射和匿名映射区就是通过mmap申请的内存\n    ")])]),v._v(" "),n("p",[v._v("20.用户空间和内核空间")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        用户空间是应用程序的运行空间。内核空间是内核的运行空间，\n        进程在用户态时，只能访问用户空间。只有进入内核态，才能访问内核空间\n    ")])]),v._v(" "),n("p",[v._v("21.进程上下文切换的过程")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n       首先会从用户态切换到内核态，然后保存进程上下文，然后加载另一个进程的进程上下文。\n    ")])]),v._v(" "),n("p",[v._v("22.CPU上下文切换")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        先将CPU上下文(CPU寄存器和程序计数器)保存起来，然后加载新任务的上下文到寄存器和程序计数器中，最后再跳转到程序计数器所指的新位置\n    ")])]),v._v(" "),n("p",[v._v("23.进程上下文是什么?")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        进程上下文包括寄存器，程序计数器，栈指针，PCB，核心栈，页表等信息\n    ")])]),v._v(" "),n("p",[v._v("24.什么是进程？什么是线程？什么是协程？")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        进程是执行中的程序。线程是进程的一个执行流程。协程是一种用户态的，不被操作系统所管理的，完全由用户控制的，比线程更加轻量级的存在\n    ")])]),v._v(" "),n("p",[v._v("25.进程和线程的区别？")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        1.进程是资源分配的单位，线程是CPU调度的单位\n        2.进程拥有完整的资源，而线程只独享必不可少的资源，如寄存器和栈\n        3.进程上下文切换需要保存更多的上下文信息，而因为同一进程的线程共享了进程的信息，故需要保存的上下文更少\n        4.多进程可以充分利用多核CPU进行并发处理，而多线程依赖于单个CPU的多个执行单元进行并发执行\n        5.线程之间的访问需要进行协同和同步，否则会出现竞争条件和死锁。\n    ")])]),v._v(" "),n("p",[v._v("26.线程上下文切换")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("P",[v._v("\n        如果两个线程属于同一个进程，则只需要切换线程的私有数据和寄存器等数据\n        如果两个线程不属于同一个进程，则和进程上下文切换一样。\n    ")])],1),v._v(" "),n("p",[v._v("27.线程和协程的区别")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        1.线程的调度由操作系统控制，而协程的调度由用户自己控制\n        2.线程的切换需要由用户态切换到内核态，而协程的切换不需要\n        3.同一时间，多核处理器的环境下，多线程可以是并行的，但是多协程是并发的\n        4.线程通常是抢占式的，而协程是协同式的。\n    ")])]),v._v(" "),n("p",[v._v("28.进程调度算法")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        进程调度算法包括先来先服务，最短作业优先，高响应比优先，时间片轮转，多级反馈队列，最高优先级\n        先来先服务对长作业有利，适合CPU密集型，不适合IO密集型的系统\n        最短作业优先，对长作业不利，可能导致长作业一直不能运行\n        高响应比优先权衡了短作业和长作业\n        最高优先级，可能会导致低优先级的作业永远无法运行\n        多级反馈队列，兼顾了长短作业，同时有较好的响应时间\n    ")])]),v._v(" "),n("p",[v._v("29.页面置换算法")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n    最佳页面置换算法(太过理想没法实现，将未来最长时间不访问的页面置换)，最近最久未使用置换算法(LRU)，先进先出置换算法(FIFO)，时钟页面替换算法(维护一个环形链表，每个页面记录一个访问标志位，置换时，遇到访问标志位为1的就将其改成0，遇到0就将其置换，当页面被访问时，将标志位设为1，最不常用算法(LFU)\n    ")])]),v._v(" "),n("p",[v._v("30.磁盘调度算法")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        先来先服务,最短寻道时间优先，扫描算法(选定某一个方向，直到最后一个磁道，才调转方向，返回途中处理请求)，循环扫描算法（选定某一个方向，直到最后一个磁道，才调转方向，返回途中不处理请求），LOOK算法（基于扫描算法的改进，磁头只会移动到最远的请求位置，然后立即反向移动，返回途中处理请求），C-LOOK算法（基于循环扫描算法的改进，磁头只会移动到最远的请求位置，然后立即反向移动，返回途中不处理请求）\n    ")])]),v._v("\n31.虚拟内存和物理内存\n"),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n\t\t虚拟内存是一种内存管理技术，将程序使用的内存地址（虚拟地址）映射到物理内存的地址。        \n    ")])]),v._v(" "),n("p",[v._v("32.select,poll,epoll")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n        select就是将已连接的socket列表拷贝到内核中，然后由内核检查是否有网络事件产生，通过遍历socket列表，然后将有网络事件产生的socket标记为可读或可写，然后再拷贝到用户态，用户态再遍历socket列表，找到可读或可写的socket,对其进行处理\n        poll就是将select使用的bitsmap替换成了链表，从而不会受到bitsmap长度的限制\n        epoll在内核中使用红黑树来关注进程所有待检测的socket,从而减少数据拷贝，使用事件驱动机制，内核里维护了一个链表来记录就绪事件，只将有事件发生的socket列表传递给应用程序，不需要扫描整个集合\n    ")])]),v._v(" "),n("p",[v._v("33.用户态和内核态")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("用户态是应用程序运行的状态，处于用户态时只能访问受限的内存")]),v._v(" "),n("p",[v._v("内核态是内核运行的状态，处于内核态时可以访问任何数据")])]),v._v(" "),n("p",[v._v("34.操作系统进行内存管理的意义？")]),v._v(" "),n("details",[n("summary",[v._v("答案")]),v._v(" "),n("p",[v._v("\n\t\t1.优化内存使用效率\n        2.保证进程之间使用内存互不干扰，保证系统的安全性\n        3.更加高效的申请和释放内存\n    ")])])])}),[],!1,null,null,null);_.default=s.exports}}]);